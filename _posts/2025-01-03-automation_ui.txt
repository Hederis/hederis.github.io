---
layout: post
title: "Removing Bottlenecks by Creating a User Interface for High Tech Processes"
permalink: /posts/automation_ui/
---

:figure-caption!:

== Removing Bottlenecks by Creating a User Interface for High Tech Processes

Introducing automation into your publishing processes can be a powerful way to reduce costs and increase speed, but when those automation tools can only be used by technical staff, you lose some of those efficiency benefits. When I worked with a publisher last year to automate some expensive processes, we controlled costs by creating the scripts first and launching those scripts with their technical team to work out any kinks before expanding to their full staff. Now it was time to build a user interface (UI) and expand the automation tools rollout to the rest of the publisher's team.

My task was to work with the publisher to determine how the UI should work, how it should interact with the existing automation scripts, and then build the app!

=== Step 1: Identify the Functionality

The first step was to meet with the publishing staff and identify the critical functionalities needed in the app. Fortunately, since I'd also built the backend automation, I already had a pretty good sense of what the app would need to do, but it's always a good idea to talk with the target users to check your own biases and blind spots. We determined the UI had to:

* Allow users to upload one or many files
* Detect whether this is the first time this book has been converted, or is a repeat conversion
* Trigger the automation scripts (running on AWS Lambda) to convert all uploaded files
* Show conversion status (in progress, success, failure)
* Show information about past conversions for any book
* Allow users with company email addresses to sign-up at will
* Set user roles (admin or regular user), and allow admins to see all existing files and delete them at will

To ensure cost efficiency, we'd leverage the existing AWS Lambda-based automation scripts, connecting them to the new UI without redevelopment. This approach retained the value of prior investments in technology while expanding accessibility.

=== Technical Architecture

The app would consist of the following new pieces:

**Frontend**: This is everything we think of as the actual user interface: all the buttons, forms, menus, etc., as well as the functions to connect the frontend to the backend and database.

**Backend**: Because the app connects to external services, we want to make sure that those connections are kept secure. While it is possible to connect via the frontend only, it is more secure to handle those connections via a non-user-facing backend.

**Database**: While the ultimate goal is to integrate with the publisher’s title management system, the current approach uses a temporary database. By adhering to the publisher’s existing naming conventions for tables and columns, future data migration will be simplified.

.The architecture and workflow for the app
image::/images/kod-ui-flow.png[alt="A flowchart showing the pieces of the app and how it connects to the automation scripts"]

=== Step 2: Designing the User Interface

To save costs and streamline development, we agreed to use a design framework rather than create custom designs for the UI. This framework provided pre-designed UI components that were generic but functional, perfectly suited for this internal tool.

Mockups were created to illustrate key functionalities, including:

* Uploading one or multiple files.
* Re-converting books that had been processed before.
* Viewing a book’s conversion history.
* Admin-specific functionalities, such as deleting books, managing server files, and accessing the database directly.

Collaboration with staff involved iterative feedback through PDF commenting, a familiar process for their review workflows. This ensured the design met user needs while staying within budget.



Save money by using a design framework: (describe what this is) a set of pre-designed UI componenets, often look fairly generic but that's fine for this project.

Put together a rough mockup of each primary piece of functionality: what will it look like to upload multiple files vs. one file, how do you reconvert a book that has already been converted, what do you see when you view a book's conversion history, what functionality will an admin have that a regular user won't (e.g., deleting books, managing files on the server, accessing the database directly), etc.

A couple rounds back and forth with staff to answer questions, using PDF commenting (a process they're used to, as it is the standard way of reviewing book files).

=== Step 3: Development Plan

Use open-source, well-established coding languages so that they will be easier to maintain by people other than myself: React for the frontend, Python/Django for the backend.

Met with their fractional CTO to learn about existing server structures and develop a deployment plan. Originally was going to use a postgresql database, but pivoted to Mysql because they already use that and have plugins for it on their server.

Using the mockups, put together a develppment plan, splitting the work into sprints. Went through and made a spreadsheet of each feature, broken down into individual components, identified components that can be reused in multiple features, and estimated amount of time required for each feature. Then split that up into 2-week sprints. This gave me a clear plan of attack, and gave the client clear expectations for what completion looks like at any stage.

=== Step 4: Development, Deployment, and Testing

Hard part is done! Using the development plan as a guide, write the code, run it locally to test, deploy at regular intervals for the client to test as well. Established a testing plan with the client as well, starting after a certain sprint (when the core functiaonlity would all be deployed) so that they could make sure the functionality meets their needs and see if they can catch any bugs or holes that I might have missed.

Delivered a fully functional app that can be used by anyone in their company, distributing the workload and speeding up their conversion time. 
</draft>
